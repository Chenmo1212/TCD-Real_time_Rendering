// Set the shader version
#version 330

// Define the output fragment color
out vec4 FragColor;

// Define input variables
in vec3 fragPosTS; // Fragment position in tangent space
in vec3 lightPosTS; // Light position in tangent space
in vec3 viewPosTS; // View position in tangent space
in vec2 texCoords; // Texture coordinates
in vec3 normalIn; // Normal vector

// Define uniform variables
uniform sampler2D diffuseMap; // Diffuse texture map
uniform sampler2D normalMap; // Normal texture map
uniform sampler2D depthMap; // Depth texture map for parallax mapping
uniform int mappingMode = 1; // Mapping mode for normal vector (1: Object space, 2: Tangent space, 3: Parallax mapping)

// Function for parallax mapping to calculate texture offset
vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir){
float depth = texture(depthMap, texCoords).r; // Get the depth value from depth texture
vec2 p = viewDir.xy * depth / viewDir.z * 0.05; // Calculate the texture offset
return texCoords - p; // Return the new texture coordinates with offset
}

void main()
{
	vec3 normal;

	// Choose the mapping mode for normal vector
	if(mappingMode == 1) {
		// If mapping mode is object space, use the normal vector from the vertex shader input
		normal = normalize(normalIn);
	}
	else if(mappingMode == 2){
		// If mapping mode is tangent space, use the normal vector from the normal texture map and convert to [-1,1] range
		normal = texture(normalMap, texCoords).rgb;
		normal = normalize(normal * 2.0 - 1.0);
	} else if(mappingMode == 3) {
		// If mapping mode is parallax mapping, calculate the texture offset and use the normal vector from the normal texture map
		vec3 viewDir = normalize(viewPosTS - fragPosTS);
		vec2 tmpTexCoords = ParallaxMapping(texCoords, viewDir);
		normal = texture(normalMap, tmpTexCoords).rgb;
		normal = normalize(normal * 2.0 - 1.0);
	}

	// Get the diffuse color from the texture map
	vec3 color = texture(diffuseMap, texCoords).rgb;

	// Calculate ambient color (60% of diffuse color)
	vec3 ambient = 0.6 * color;

	// Calculate diffuse color
	vec3 lightDir = normalize(lightPosTS - fragPosTS);
	float diff = max(dot(lightDir, normal), 0.0);
	vec3 diffuse = diff * color;

	// Calculate specular color using Phong reflection model
	vec3 viewDir = normalize(viewPosTS - fragPosTS);
	vec3 halfwayDir = normalize(lightDir + viewDir);
	float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);
	vec3 specular = vec3(0.2) * spec;

	// Combine ambient, diffuse, and specular colors and output the final fragment color
	FragColor = vec4(ambient + diffuse + specular, 1.0);
}